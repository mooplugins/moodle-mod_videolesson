{"version":3,"file":"script.min.js","sources":["../src/script.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Script utilities for videolesson plugin\n *\n * @module     mod_videolesson/script\n * @copyright  2022-2026 BitKea Technologies LLP\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport Ajax from 'core/ajax';\nimport ModalFactory from 'core/modal_factory';\nimport ModalEvents from 'core/modal_events';\nimport {get_string as getString} from 'core/str';\nimport * as Debug from 'mod_videolesson/debug';\nimport {\n    HLS_INIT_TIMEOUT,\n    SEEK_BLOCK_TIMEOUT,\n    VIMEO_API_CHECK_INTERVAL,\n    VIMEO_API_TIMEOUT,\n    YOUTUBE_API_TIMEOUT,\n} from 'mod_videolesson/constants';\n\nconst getTargetTime = (plyr, input) => {\n    if (typeof input === \"object\" && (input.type === \"input\" || input.type === \"change\")) {\n        const max = input.target.max;\n        if (max === 0 || !max) {\n            return 0;\n        }\n        return input.target.value / max * plyr.duration;\n    } else {\n        return Number(input);\n    }\n};\n\nconst showSeekingAlertDialog = async () => {\n    const modal = await ModalFactory.create({\n        title: getString('player:seeking:disabled:header', 'mod_videolesson'),\n        body: getString('player:seeking:disabled:description', 'mod_videolesson'),\n        type: ModalFactory.types.CANCEL,\n        buttons: {\n            cancel: getString('gotit', 'mod_videolesson')\n        }\n    });\n\n    const cancelButton = modal.getRoot().find('[data-action=\"cancel\"]');\n    cancelButton.removeClass('btn-secondary').addClass('btn-primary');\n\n    return new Promise((resolve) => {\n        modal.getRoot().on(ModalEvents.cancel, () => {\n            resolve(false);\n            modal.hide();\n        });\n\n        modal.getRoot().on(ModalEvents.hidden, () => {\n            modal.destroy();\n        });\n\n        modal.show();\n    });\n};\n\n// Removed module-level isSeekingBlocked - now using function-scoped variable\n\nexport const initializePlayer = (params) => {\n    return new Promise((resolve, reject) => {\n\n        let videoPlyr;\n        let isSeekBlocked = false; // Track if seek is currently blocked to prevent multiple dialogs\n\n        const playerDefaultOptions = {\n            listeners: {\n                // disallow moving forward\n                seek: function customSeekBehavior(e) {\n                    if (params.disableseek && params.student && params.video) {\n                        const current_time = videoPlyr.currentTime;\n                        const newTime = getTargetTime(videoPlyr, e);\n                        const maxwatched = parseFloat(params.video?.dataset?.maxwatched || 0);\n\n                        let shouldBlockSeek = false;\n\n                        if (params.allowrewind) {\n                            // Allow backward seek, block only if seeking beyond maxwatched\n                            if (parseFloat(newTime) > maxwatched) {\n                                shouldBlockSeek = true;\n                            }\n                        } else {\n                            // Don't allow any seeking at all (forward or backward)\n                            if (parseFloat(newTime) !== current_time) {\n                                shouldBlockSeek = true;\n                            }\n                        }\n\n                        if (shouldBlockSeek) {\n                            e.preventDefault();\n                            videoPlyr.pause();\n\n                            if (!isSeekBlocked) {\n                                isSeekBlocked = true;\n                                showSeekingAlertDialog();\n\n                                setTimeout(() => {\n                                    isSeekBlocked = false;\n                                }, SEEK_BLOCK_TIMEOUT);\n                            }\n\n                            // Reset to the original time\n                            videoPlyr.currentTime = current_time;\n\n                            return false;\n                        }\n                    }\n                }\n            },\n            captions: { active: true, update: true, language: 'en' },\n            settings: [],\n            controls: []\n        };\n\n        const settingControls = [\n            'play',\n            'progress',\n            'current-time',\n            'mute',\n            'volume',\n            'captions',\n            'settings',\n            'fullscreen',\n            ...(params.pip ? ['pip'] : [])\n        ];\n\n        const settingOptions = [\n            'captions',\n            'quality',\n            'loop',\n            ...(params.speed ? ['speed'] : [])\n        ];\n\n        playerDefaultOptions.settings = settingOptions;\n        playerDefaultOptions.controls = settingControls;\n\n        // Check for embedded videos (YouTube/Vimeo) - both 'embed' and 'external' providers\n        if ((params.provider === 'embed' || params.provider === 'external') && params.externaltype === 'youtube') {\n            Debug.log('Configuring YouTube embed player', {\n                provider: params.provider,\n                externaltype: params.externaltype\n            });\n            playerDefaultOptions.youtube = {\n                noCookie: true,\n                rel: 0,\n                modestbranding: 1\n            };\n        }\n\n        if ((params.provider === 'embed' || params.provider === 'external') && params.externaltype === 'vimeo') {\n            Debug.log('Configuring Vimeo embed player', {\n                provider: params.provider,\n                externaltype: params.externaltype\n            });\n            playerDefaultOptions.vimeo = {\n                dnt: true\n            };\n        }\n\n        if (params.ishls && params.video) {\n            const source = params.video?.dataset?.source;\n            if (!source) {\n                reject(new Error('HLS source not found'));\n                return;\n            }\n            // eslint-disable-next-line no-undef\n            const hls = new Hls();\n\n            // Load the HLS source\n            hls.loadSource(source);\n\n            // Add timeout for HLS initialization\n            const hlsTimeout = setTimeout(() => {\n                const errorMessage = 'HLS initialization timed out.';\n                Debug.error(errorMessage);\n                displayErrorMessage(errorMessage, params.video);\n                reject(new Error(errorMessage));\n            }, HLS_INIT_TIMEOUT);\n\n            // eslint-disable-next-line no-undef\n            hls.on(Hls.Events.MANIFEST_PARSED, function () {\n                clearTimeout(hlsTimeout); // Clear the timeout\n\n                const availableQualities = hls.levels.map((l) => l.height);\n                availableQualities.unshift(0); // Prepend 0 to quality array\n\n                playerDefaultOptions.quality = {\n                    default: 0, // Default - AUTO\n                    options: availableQualities,\n                    forced: true,\n                    onChange: (e) => updateQuality(e),\n                };\n\n                playerDefaultOptions.i18n = {\n                    qualityLabel: {\n                        0: 'Auto',\n                    },\n                };\n\n                // eslint-disable-next-line no-undef\n                hls.on(Hls.Events.LEVEL_SWITCHED, function (event, data) {\n                    const span = document.querySelector(\".plyr__menu__container [data-plyr='quality'][value='0'] span\");\n                    if (span) {\n                        if (hls.autoLevelEnabled) {\n                            span.innerHTML = `AUTO (${hls.levels[data.level].height}p)`;\n                        } else {\n                            span.innerHTML = `AUTO`;\n                        }\n                    }\n                });\n\n                // Initialize Plyr instance\n                // eslint-disable-next-line no-undef\n                videoPlyr = new Plyr(params.video, playerDefaultOptions);\n                // Store in namespaced global for debugging only\n                if (typeof window !== 'undefined' && Debug.isDebugEnabled()) {\n                    // eslint-disable-next-line no-undef\n                    window.videolesson = window.videolesson || {};\n                    // eslint-disable-next-line no-undef\n                    window.videolesson.player = videoPlyr;\n                }\n\n                // Resolve the promise with the Plyr instance\n                resolve(videoPlyr);\n            });\n\n            // Attach media to HLS\n            hls.attachMedia(params.video);\n            // Store in namespaced global for debugging only\n            if (typeof window !== 'undefined' && Debug.isDebugEnabled()) {\n                // eslint-disable-next-line no-undef\n                window.videolesson = window.videolesson || {};\n                // eslint-disable-next-line no-undef\n                window.videolesson.hls = hls;\n            }\n\n            // Handle error events\n            // eslint-disable-next-line no-undef\n            hls.on(Hls.Events.ERROR, function (event, data) {\n                clearTimeout(hlsTimeout); // Clear the timeout\n                let errorMessage = 'An unknown error occurred.';\n                // eslint-disable-next-line no-undef\n                switch (data.type) {\n                    // eslint-disable-next-line no-undef\n                    case Hls.ErrorTypes.NETWORK_ERROR:\n                        errorMessage = 'A network error occurred while fetching the media.';\n                        break;\n                    // eslint-disable-next-line no-undef\n                    case Hls.ErrorTypes.MEDIA_ERROR:\n                        errorMessage = 'An error occurred while loading the media.';\n                        break;\n                    // eslint-disable-next-line no-undef\n                    case Hls.ErrorTypes.OTHER_ERROR:\n                        errorMessage = 'An unexpected error occurred.';\n                        break;\n                }\n\n                Debug.error('HLS Error', {message: errorMessage, data: data});\n                displayErrorMessage(errorMessage, params.video);\n                reject(new Error(errorMessage)); // Reject the promise with error details\n            });\n        } else {\n            // Check if this is an embed that needs API loading\n            const isEmbed = (params.provider === 'embed' || params.provider === 'external') &&\n                           (params.externaltype === 'youtube' || params.externaltype === 'vimeo');\n\n            if (isEmbed) {\n                // Wait for YouTube/Vimeo API to be ready\n                const waitForAPI = () => {\n                    return new Promise((resolveAPI) => {\n                        if (params.externaltype === 'youtube') {\n                            if (window.YT && window.YT.Player) {\n                                Debug.log('YouTube API ready');\n                                resolveAPI();\n                            } else {\n                                Debug.log('Waiting for YouTube API...');\n                                // Store existing handler if any, then set our own\n                                const existingHandler = window.onYouTubeIframeAPIReady;\n                                // eslint-disable-next-line no-undef\n                                window.onYouTubeIframeAPIReady = () => {\n                                    // Call existing handler if it exists\n                                    if (existingHandler && typeof existingHandler === 'function') {\n                                        existingHandler();\n                                    }\n                                    Debug.log('YouTube API ready (callback)');\n                                    resolveAPI();\n                                };\n                                // Fallback timeout\n                                const timeoutId = setTimeout(() => {\n                                    Debug.log('YouTube API timeout, proceeding anyway');\n                                    resolveAPI();\n                                }, YOUTUBE_API_TIMEOUT);\n                                // Store timeout ID for potential cleanup\n                                if (resolveAPI.timeoutId) {\n                                    clearTimeout(resolveAPI.timeoutId);\n                                }\n                                resolveAPI.timeoutId = timeoutId;\n                            }\n                        } else if (params.externaltype === 'vimeo') {\n                            if (window.Vimeo && window.Vimeo.Player) {\n                                Debug.log('Vimeo API ready');\n                                resolveAPI();\n                            } else {\n                                Debug.log('Waiting for Vimeo API...');\n                                // Check periodically\n                                let checkInterval = setInterval(() => {\n                                    if (window.Vimeo && window.Vimeo.Player) {\n                                        clearInterval(checkInterval);\n                                        checkInterval = null;\n                                        Debug.log('Vimeo API ready');\n                                        resolveAPI();\n                                    }\n                                }, VIMEO_API_CHECK_INTERVAL);\n                                // Fallback timeout\n                                const timeoutId = setTimeout(() => {\n                                    if (checkInterval) {\n                                        clearInterval(checkInterval);\n                                        checkInterval = null;\n                                    }\n                                    Debug.log('Vimeo API timeout, proceeding anyway');\n                                    resolveAPI();\n                                }, VIMEO_API_TIMEOUT);\n                                // Store references for cleanup\n                                resolveAPI.cleanup = () => {\n                                    if (checkInterval) {\n                                        clearInterval(checkInterval);\n                                        checkInterval = null;\n                                    }\n                                    clearTimeout(timeoutId);\n                                };\n                            }\n                        } else {\n                            resolveAPI();\n                        }\n                    });\n                };\n\n                waitForAPI().then(() => {\n                    try {\n                        Debug.log('Initializing Plyr player (embed)', {\n                            provider: params.provider,\n                            externaltype: params.externaltype,\n                            element: params.video?.tagName,\n                            className: params.video?.className,\n                            hasIframe: !!params.video?.querySelector('iframe')\n                        });\n\n                        // eslint-disable-next-line no-undef\n                        videoPlyr = new Plyr(params.video, playerDefaultOptions);\n                        // Store in namespaced global for debugging only\n                        if (typeof window !== 'undefined' && Debug.isDebugEnabled()) {\n                            // eslint-disable-next-line no-undef\n                            window.videolesson = window.videolesson || {};\n                            // eslint-disable-next-line no-undef\n                            window.videolesson.player = videoPlyr;\n                        }\n\n                        Debug.log('Plyr instance created (embed)', {\n                            hasEmbed: !!videoPlyr.embed,\n                            embedProvider: videoPlyr.embed?.provider,\n                            duration: videoPlyr.duration\n                        });\n\n                        resolve(videoPlyr);\n                    } catch (error) {\n                        Debug.error('Error initializing embed player', error);\n                        reject(error);\n                    }\n                });\n            } else {\n                try {\n                    Debug.log('Initializing Plyr player (non-HLS)', {\n                        provider: params.provider,\n                        externaltype: params.externaltype,\n                        element: params.video?.tagName,\n                        className: params.video?.className,\n                        hasIframe: !!params.video?.querySelector('iframe')\n                    });\n\n                    // eslint-disable-next-line no-undef\n                    videoPlyr = new Plyr(params.video, playerDefaultOptions);\n                    // Store in namespaced global for debugging only\n                    if (typeof window !== 'undefined' && Debug.isDebugEnabled()) {\n                        // eslint-disable-next-line no-undef\n                        window.videolesson = window.videolesson || {};\n                        // eslint-disable-next-line no-undef\n                        window.videolesson.player = videoPlyr;\n                    }\n\n                    Debug.log('Plyr instance created', {\n                        hasEmbed: !!videoPlyr.embed,\n                        embedProvider: videoPlyr.embed?.provider,\n                        duration: videoPlyr.duration\n                    });\n\n                    resolve(videoPlyr); // Resolve the promise with the Plyr instance\n                } catch (error) {\n                    Debug.error('Error initializing non-HLS player', error);\n                    reject(error);\n                }\n            }\n        }\n    });\n};\n\n/**\n * Display error message in player container\n * @param {string} message - Error message to display\n * @param {HTMLElement|null} video - Video element\n */\nconst displayErrorMessage = async(message, video = null) => {\n    if (!video) {\n        Debug.error('Video element not provided for error display');\n        return;\n    }\n\n    let playerContainer;\n    const hash = video?.dataset?.hash;\n    if (hash) {\n        playerContainer = document.querySelector(`#player-placeholder-${hash}`);\n    } else {\n        playerContainer = document.querySelector(`#player-placeholder`);\n    }\n\n    if (!playerContainer) {\n        Debug.error('Player container not found');\n        return;\n    }\n\n    try {\n        playerContainer.innerHTML = await Templates.render('mod_videolesson/error_player', {message: message});\n\n        const retryButton = playerContainer.querySelector('.retry-button');\n        if (retryButton) {\n            retryButton.addEventListener('click', () => {\n                window.location.reload();\n            });\n        } else {\n            Debug.warn('Retry button not found inside player container');\n        }\n    } catch (error) {\n        Debug.error('Error rendering error message template', error);\n    }\n};\n\n/**\n * Update video quality for HLS playback\n * @param {number} newQuality - Quality level to set\n */\nconst updateQuality = newQuality => {\n    // eslint-disable-next-line no-undef\n    const hls = window.videolesson?.hls;\n    if (!hls) {\n        Debug.warn('HLS instance not available for quality update');\n        return;\n    }\n    try {\n        if (newQuality === 0) {\n            hls.currentLevel = -1; // Enable AUTO quality if option.value = 0\n        } else {\n            hls.levels.forEach((level, levelIndex) => {\n                if (level.height === newQuality) {\n                    hls.currentLevel = levelIndex;\n                }\n            });\n        }\n    } catch (error) {\n        Debug.error('Error updating quality', error);\n    }\n};\n\nexport const secondsToMinutesAndSeconds = (seconds) => {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    const minutesString = String(minutes).padStart(2, '0');\n    const secondsString = String(remainingSeconds).padStart(2, '0');\n    return minutesString + ':' + secondsString;\n};\n\nexport const getUrlParameter = (name) => {\n    const escapedName = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n    const regex = new RegExp('[\\\\?&]' + escapedName + '=([^&#]*)');\n    const results = regex.exec(window.location.search);\n    return results === null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' '));\n};\n\nexport const getSubtitles = (contenthash) => {\n    return new Promise((resolve, reject) => {\n        Ajax.call([{\n            methodname: 'mod_videolesson_getsubtitles',\n            args: { contenthash: contenthash },\n            done: function (response) {\n                resolve(response);\n            },\n            fail: function (error) {\n                reject(error);\n            }\n        }]);\n    });\n};\n\nexport const addSubtitleTracks = (video, tracks) => {\n    tracks.forEach(track => {\n        const trackEl = document.createElement('track');\n        trackEl.kind = 'subtitles';\n        trackEl.label = track.language;\n        trackEl.srclang = track.code;\n        trackEl.src = track.url;\n        if (track.default) {\n            trackEl.default = true;\n        }\n        video.appendChild(trackEl);\n    });\n};\n"],"names":["params","Promise","resolve","reject","videoPlyr","isSeekBlocked","playerDefaultOptions","listeners","seek","e","disableseek","student","video","current_time","currentTime","newTime","plyr","input","type","Number","max","target","value","duration","getTargetTime","maxwatched","parseFloat","dataset","shouldBlockSeek","allowrewind","preventDefault","pause","async","modal","ModalFactory","create","title","body","types","CANCEL","buttons","cancel","getRoot","find","removeClass","addClass","on","ModalEvents","hide","hidden","destroy","show","showSeekingAlertDialog","setTimeout","SEEK_BLOCK_TIMEOUT","captions","active","update","language","settings","controls","settingControls","pip","settingOptions","speed","provider","externaltype","Debug","log","youtube","noCookie","rel","modestbranding","vimeo","dnt","ishls","source","_params$video2","_params$video2$datase","Error","hls","Hls","loadSource","hlsTimeout","errorMessage","error","displayErrorMessage","HLS_INIT_TIMEOUT","Events","MANIFEST_PARSED","clearTimeout","availableQualities","levels","map","l","height","unshift","quality","default","options","forced","onChange","updateQuality","i18n","qualityLabel","LEVEL_SWITCHED","event","data","span","document","querySelector","autoLevelEnabled","innerHTML","level","Plyr","window","isDebugEnabled","videolesson","player","attachMedia","ERROR","ErrorTypes","NETWORK_ERROR","MEDIA_ERROR","OTHER_ERROR","message","resolveAPI","YT","Player","existingHandler","onYouTubeIframeAPIReady","timeoutId","YOUTUBE_API_TIMEOUT","Vimeo","checkInterval","setInterval","clearInterval","VIMEO_API_CHECK_INTERVAL","VIMEO_API_TIMEOUT","cleanup","waitForAPI","then","element","_params$video3","tagName","className","_params$video4","hasIframe","_params$video5","hasEmbed","embed","embedProvider","_videoPlyr$embed","_params$video6","_params$video7","_params$video8","_videoPlyr$embed2","playerContainer","hash","_video$dataset","Templates","render","retryButton","addEventListener","location","reload","warn","newQuality","_window$videolesson","currentLevel","forEach","levelIndex","seconds","minutes","Math","floor","remainingSeconds","String","padStart","name","escapedName","replace","results","RegExp","exec","search","decodeURIComponent","contenthash","call","methodname","args","done","response","fail","tracks","track","trackEl","createElement","kind","label","srclang","code","src","url","appendChild"],"mappings":"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"}