{"version":3,"file":"modal_table.min.js","sources":["../src/modal_table.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Modal table functionality for videolesson plugin\n *\n * @module     mod_videolesson/modal_table\n * @copyright  2022-2026 BitKea Technologies LLP\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport ModalEvents from 'core/modal_events';\nimport * as Debug from 'mod_videolesson/debug';\n\n/**\n * Filter table rows for modal-based tables.\n * @param {HTMLElement} tableElement - The table element.\n * @param {HTMLElement} inputElement - The input element for filtering.\n * @param {number} columnIndex - The column index to filter.\n */\nconst filterTableByElement = (tableElement, inputElement, columnIndex) => {\n    const filter = inputElement?.value.toLowerCase();\n    const rows = tableElement?.getElementsByTagName(\"tr\");\n\n    if (!rows) {\n        return;\n    }\n\n    for (let i = 1; i < rows.length; i++) { // Skip header row\n        const cell = rows[i].getElementsByTagName(\"td\")[columnIndex];\n        if (cell) {\n            const textValue = cell.textContent || cell.innerText;\n            rows[i].style.display = textValue.toLowerCase().includes(filter) ? \"\" : \"none\";\n        }\n    }\n};\n\n/**\n * Sort table rows for modal-based tables.\n * @param {HTMLElement} tableElement - The table element.\n * @param {number} columnIndex - The column index to sort.\n */\nconst sortTableByElement = (tableElement, columnIndex) => {\n    const rows = Array.from(tableElement?.rows || []).slice(1); // Get all rows except the header\n    if (rows.length === 0) {\n        return;\n    }\n\n    const isNumeric = !isNaN(rows[0].cells[columnIndex].innerText);\n    const sortOrderAttr = `data-sort-order-${columnIndex}`;\n    const ascending = tableElement.getAttribute(sortOrderAttr) !== \"asc\";\n\n    rows.sort((a, b) => {\n        const aValue = a.cells[columnIndex].innerText.toLowerCase();\n        const bValue = b.cells[columnIndex].innerText.toLowerCase();\n\n        if (isNumeric) {\n            return ascending\n                ? parseFloat(aValue) - parseFloat(bValue)\n                : parseFloat(bValue) - parseFloat(aValue);\n        }\n        return ascending\n            ? aValue.localeCompare(bValue)\n            : bValue.localeCompare(aValue);\n    });\n\n    // Toggle sort order\n    tableElement.setAttribute(sortOrderAttr, ascending ? \"asc\" : \"desc\");\n\n    const tbody = tableElement.querySelector(\"tbody\");\n    if (tbody) {\n        tbody.innerHTML = \"\";\n        rows.forEach(row => tbody.appendChild(row));\n    }\n\n    updateSortIndicators(tableElement, columnIndex, ascending);\n};\n\n\n/**\n * Apply paging functionality to a table element.\n * @param {HTMLElement} tableElement - The table element.\n * @param {number} rowsPerPage - The number of rows per page.\n */\n// eslint-disable-next-line no-unused-vars\nconst addPagingToTableElement = (tableElement, rowsPerPage = 10) => {\n    if (!tableElement) {\n        Debug.error(\"Table element is not provided\");\n        return;\n    }\n\n    const rows = tableElement.getElementsByTagName(\"tr\");\n    if (!rows || rows.length <= 1) {\n        return;\n    }\n\n    const totalRows = rows.length - 1; // Exclude header row\n    const totalPages = Math.ceil(totalRows / rowsPerPage);\n    let currentPage = 1;\n\n    const renderTablePage = (page) => {\n        const start = (page - 1) * rowsPerPage + 1; // Skip header row\n        const end = start + rowsPerPage;\n\n        for (let i = 1; i < rows.length; i++) {\n            rows[i].style.display = i >= start && i < end ? \"\" : \"none\";\n        }\n\n        updatePagingControls(tableElement, currentPage, totalPages);\n    };\n\n    const createPagingControls = () => {\n        const pagingContainer = document.createElement(\"div\");\n        pagingContainer.className = \"table-paging-controls\";\n        pagingContainer.style.textAlign = \"center\";\n        pagingContainer.style.marginTop = \"10px\";\n\n        // Add controls after the table\n        tableElement.parentElement.appendChild(pagingContainer);\n    };\n\n    const updatePagingControls = (tableElement, pageNum, totalPages) => {\n        const pagingContainer = tableElement.parentElement.querySelector(\".table-paging-controls\");\n        pagingContainer.innerHTML = \"\"; // Clear previous controls\n\n        // Helper function to create page change handler\n        const createPageHandler = (newPage) => {\n            return () => {\n                currentPage = newPage;\n                renderTablePage(currentPage);\n            };\n        };\n\n        // Helper function to create increment/decrement handler\n        const createPageIncrementHandler = (delta) => {\n            return () => {\n                currentPage += delta;\n                renderTablePage(currentPage);\n            };\n        };\n\n        if (pageNum > 1) {\n            const prevButton = document.createElement(\"button\");\n            prevButton.innerText = \"Previous\";\n            prevButton.onclick = createPageIncrementHandler(-1);\n            pagingContainer.appendChild(prevButton);\n        }\n\n        for (let i = 1; i <= totalPages; i++) {\n            const pageNumber = i; // Capture loop variable in block scope\n            const pageButton = document.createElement(\"button\");\n            pageButton.innerText = pageNumber;\n            pageButton.disabled = pageNumber === pageNum;\n            pageButton.onclick = createPageHandler(pageNumber);\n            pagingContainer.appendChild(pageButton);\n        }\n\n        if (pageNum < totalPages) {\n            const nextButton = document.createElement(\"button\");\n            nextButton.innerText = \"Next\";\n            nextButton.onclick = createPageIncrementHandler(1);\n            pagingContainer.appendChild(nextButton);\n        }\n    };\n\n    // Initialize paging\n    createPagingControls();\n    renderTablePage(currentPage);\n};\n\n/**\n * Update sort indicators for the table headers.\n * @param {HTMLElement} table - The table element.\n * @param {number} columnIndex - The sorted column index.\n * @param {boolean} ascending - Whether the sort is ascending.\n */\nconst updateSortIndicators = (table, columnIndex, ascending) => {\n    const headers = table.querySelectorAll(\"th\");\n    headers.forEach((header, index) => {\n        header.setAttribute(\n            \"data-sort-indicator\",\n            index === columnIndex ? (ascending ? \"▲\" : \"▼\") : \"\"\n        );\n    });\n};\n\n\n/**\n * Populate the table with new data.\n * @param {HTMLElement} tableElement - The table element to populate.\n * @param {Array<Object>} data - Array of objects representing table rows.\n * @param {Array<string>} columns - List of keys representing table columns.\n */\n// eslint-disable-next-line no-unused-vars\nconst populateTable = (tableElement, data, columns) => {\n    if (!tableElement) {\n        Debug.error(\"Table element is not provided\");\n        return;\n    }\n\n    const tbody = tableElement.querySelector(\"tbody\");\n    if (!tbody) {\n        Debug.error(\"Table body element is not found\");\n        return;\n    }\n\n    // Clear the existing table body\n    tbody.innerHTML = \"\";\n\n    // Populate the table with new rows\n    data.forEach((row) => {\n        const tr = document.createElement(\"tr\");\n\n        columns.forEach((column) => {\n            const td = document.createElement(\"td\");\n            td.innerText = row[column] || \"\"; // Use column keys to fetch data\n            tr.appendChild(td);\n        });\n\n        tbody.appendChild(tr);\n    });\n\n    Debug.log(\"Table repopulated with new data\");\n};\n\n/**\n * Initialize a modal table for sorting and filtering functionality.\n * @param {object} modal - The modal object (assuming it has `getRoot` method).\n * @param {number} filterColumnIndex - The index of the column for filtering.\n */\nexport const initModalTable = (modal, filterColumnIndex = 0) => {\n    if (!modal) {\n        Debug.error('Modal instance is not provided');\n        return;\n    }\n\n    const $root = modal.getRoot();\n\n    if ($root && $root.length) {\n        $root.on(ModalEvents.shown, () => {\n            const tableElement = modal.getRoot().find('table').get(0);\n            const inputElement = modal.getRoot().find('#videolistsearchinput').get(0);\n\n            if (!tableElement) {\n                Debug.error('Table element is not provided or not found');\n                return;\n            }\n            //addPagingToTableElement(tableElement, 2);\n            const headers = tableElement.querySelectorAll(\"th\");\n            headers.forEach((header, index) => {\n                header.addEventListener(\"click\", () => sortTableByElement(tableElement, index));\n            });\n\n            if (inputElement) {\n                inputElement.addEventListener(\"input\", () =>\n                    filterTableByElement(tableElement, inputElement, filterColumnIndex)\n                );\n            }\n\n            tableElement.addEventListener('click', (event) => {\n                const row = event.target.closest('tr');\n                if (!row || !tableElement.contains(row)) {\n                    return;\n                }\n                const hash = row.dataset.contenthash;\n                const title = row.dataset.title;\n                if (hash) {\n                    const rows = tableElement.querySelectorAll('tbody tr');\n                    rows.forEach(r => r.classList.remove('selected'));\n                    row.classList.add('selected');\n                    tableElement.dataset.selected = hash;\n                    tableElement.dataset.title = title;\n                } else {\n                    Debug.warn('No content hash found for the selected row');\n                }\n            });\n        });\n    } else {\n        Debug.error('Modal root element not found or empty');\n    }\n};\n"],"names":["filterTableByElement","tableElement","inputElement","columnIndex","filter","value","toLowerCase","rows","getElementsByTagName","i","length","cell","textValue","textContent","innerText","style","display","includes","sortTableByElement","Array","from","slice","isNumeric","isNaN","cells","sortOrderAttr","ascending","getAttribute","sort","a","b","aValue","bValue","parseFloat","localeCompare","setAttribute","tbody","querySelector","innerHTML","forEach","row","appendChild","updateSortIndicators","table","querySelectorAll","header","index","modal","filterColumnIndex","Debug","error","$root","getRoot","on","ModalEvents","shown","find","get","addEventListener","event","target","closest","contains","hash","dataset","contenthash","title","r","classList","remove","add","selected","warn"],"mappings":";;;;;;;mlCAgCMA,qBAAuB,CAACC,aAAcC,aAAcC,qBAChDC,OAASF,MAAAA,oBAAAA,aAAcG,MAAMC,cAC7BC,KAAON,MAAAA,oBAAAA,aAAcO,qBAAqB,SAE3CD,SAIA,IAAIE,EAAI,EAAGA,EAAIF,KAAKG,OAAQD,IAAK,OAC5BE,KAAOJ,KAAKE,GAAGD,qBAAqB,MAAML,gBAC5CQ,KAAM,OACAC,UAAYD,KAAKE,aAAeF,KAAKG,UAC3CP,KAAKE,GAAGM,MAAMC,QAAUJ,UAAUN,cAAcW,SAASb,QAAU,GAAK,UAU9Ec,mBAAqB,CAACjB,aAAcE,qBAChCI,KAAOY,MAAMC,MAAKnB,MAAAA,oBAAAA,aAAcM,OAAQ,IAAIc,MAAM,MACpC,IAAhBd,KAAKG,oBAIHY,WAAaC,MAAMhB,KAAK,GAAGiB,MAAMrB,aAAaW,WAC9CW,wCAAmCtB,aACnCuB,UAAyD,QAA7CzB,aAAa0B,aAAaF,eAE5ClB,KAAKqB,MAAK,CAACC,EAAGC,WACJC,OAASF,EAAEL,MAAMrB,aAAaW,UAAUR,cACxC0B,OAASF,EAAEN,MAAMrB,aAAaW,UAAUR,qBAE1CgB,UACOI,UACDO,WAAWF,QAAUE,WAAWD,QAChCC,WAAWD,QAAUC,WAAWF,QAEnCL,UACDK,OAAOG,cAAcF,QACrBA,OAAOE,cAAcH,WAI/B9B,aAAakC,aAAaV,cAAeC,UAAY,MAAQ,cAEvDU,MAAQnC,aAAaoC,cAAc,SACrCD,QACAA,MAAME,UAAY,GAClB/B,KAAKgC,SAAQC,KAAOJ,MAAMK,YAAYD,QAG1CE,qBAAqBzC,aAAcE,YAAauB,YAqG9CgB,qBAAuB,CAACC,MAAOxC,YAAauB,aAC9BiB,MAAMC,iBAAiB,MAC/BL,SAAQ,CAACM,OAAQC,SACrBD,OAAOV,aACH,sBACAW,QAAU3C,YAAeuB,UAAY,IAAM,IAAO,gCAiDhC,SAACqB,WAAOC,yEAAoB,MACjDD,kBACDE,MAAMC,MAAM,wCAIVC,MAAQJ,MAAMK,UAEhBD,OAASA,MAAMzC,OACfyC,MAAME,GAAGC,sBAAYC,OAAO,WAClBtD,aAAe8C,MAAMK,UAAUI,KAAK,SAASC,IAAI,GACjDvD,aAAe6C,MAAMK,UAAUI,KAAK,yBAAyBC,IAAI,OAElExD,yBACDgD,MAAMC,MAAM,8CAIAjD,aAAa2C,iBAAiB,MACtCL,SAAQ,CAACM,OAAQC,SACrBD,OAAOa,iBAAiB,SAAS,IAAMxC,mBAAmBjB,aAAc6C,YAGxE5C,cACAA,aAAawD,iBAAiB,SAAS,IACnC1D,qBAAqBC,aAAcC,aAAc8C,qBAIzD/C,aAAayD,iBAAiB,SAAUC,cAC9BnB,IAAMmB,MAAMC,OAAOC,QAAQ,UAC5BrB,MAAQvC,aAAa6D,SAAStB,kBAG7BuB,KAAOvB,IAAIwB,QAAQC,YACnBC,MAAQ1B,IAAIwB,QAAQE,SACtBH,KAAM,CACO9D,aAAa2C,iBAAiB,YACtCL,SAAQ4B,GAAKA,EAAEC,UAAUC,OAAO,cACrC7B,IAAI4B,UAAUE,IAAI,YAClBrE,aAAa+D,QAAQO,SAAWR,KAChC9D,aAAa+D,QAAQE,MAAQA,WAE7BjB,MAAMuB,KAAK,oDAKvBvB,MAAMC,MAAM"}