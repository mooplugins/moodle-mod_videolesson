{"version":3,"file":"vplyr.min.js","sources":["../src/vplyr.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Plyr player functionality for videolesson plugin\n *\n * @module     mod_videolesson/vplyr\n * @copyright  2022-2026 BitKea Technologies LLP\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport ModalFactory from 'core/modal_factory';\nimport ModalEvents from 'core/modal_events';\nimport * as Toast from 'core/toast';\nimport {get_string as getString} from 'core/str';\nimport {addSubtitleTracks, initializePlayer } from 'mod_videolesson/script';\nimport * as Debug from 'mod_videolesson/debug';\nimport {\n    CHART_UPDATE_DEBOUNCE,\n    MAX_RANGE_HISTORY,\n    SEND_INTERVAL\n} from 'mod_videolesson/constants';\n\nlet video,\n    mediaElement,\n    videoPlayer,\n    browserData,\n    videoData,\n    tracking = true,\n    chart,\n    percentageEl,\n    playerContainer,\n    playerPlaceholder,\n    completiondetails,\n    previousTime = 0,\n    lastSendTime = 0,\n    seekStart = null,\n    playbackRanges = [],\n    existingRanges = [],\n    fromSeek = false,\n    fromResume = false,\n    isPlaying = false,\n    visibilityChangeHandler = null,\n    plyrEventHandlers = [],\n    chartUpdateTimeout = null,\n    lastChartDataHash = null,\n    sendDataRetryCount = 0,\n    sendDataQueue = [],\n    storedInitParams = null; // eslint-disable-line no-unused-vars\n\n/**\n * Merge overlapping ranges into non-overlapping ranges\n * @param {Array<Array<number>>} ranges - Array of range pairs [start, end]\n * @returns {Array<Array<number>>} Merged non-overlapping ranges\n */\nconst mergeRanges = (ranges) => {\n    if (!ranges || !ranges.length) {\n        return [];\n    }\n    const sorted = ranges.slice().sort((a, b) => a[0] - b[0]);\n    const merged = [sorted[0].slice()];\n    for (let i = 1; i < sorted.length; i++) {\n        const current = sorted[i];\n        const last = merged[merged.length - 1];\n        if (current[0] <= last[1]) {\n            last[1] = Math.max(last[1], current[1]);\n        } else {\n            merged.push(current.slice());\n        }\n    }\n    return merged;\n};\n\n/**\n * Add a playback range to track watched segments\n * @param {number} start - Start time in seconds\n * @param {number} end - End time in seconds\n */\nconst addPlaybackRange = (start, end) => {\n    // Validate inputs\n    if (!videoData || !videoPlayer) {\n        return;\n    }\n    if (Number.isNaN(start) || Number.isNaN(end) || start < 0 || end < 0) {\n        return;\n    }\n\n    let rangeStart = Math.min(start, end);\n    let rangeEnd = Math.max(start, end);\n    if (rangeEnd <= rangeStart) {\n        return;\n    }\n\n    const duration = videoData.duration || videoPlayer?.duration || 0;\n    if (duration > 0) {\n        rangeStart = Math.max(0, Math.min(rangeStart, duration));\n        rangeEnd = Math.max(0, Math.min(rangeEnd, duration));\n        if (rangeEnd <= rangeStart) {\n            return;\n        }\n    }\n\n    playbackRanges.push([rangeStart, rangeEnd]);\n    playbackRanges = mergeRanges(playbackRanges);\n\n    // Limit range history to prevent memory issues\n    if (playbackRanges.length > MAX_RANGE_HISTORY) {\n        // Keep only the most recent ranges\n        playbackRanges = playbackRanges.slice(-MAX_RANGE_HISTORY);\n    }\n};\n\n/**\n * Copy TimeRanges object to array format\n * @param {TimeRanges} timeRanges - Browser TimeRanges object\n * @returns {Array<Array<number>>} Array of range pairs [start, end]\n */\nconst copyRanges = (timeRanges) => {\n    if (!timeRanges || timeRanges.length === 0) {\n        return [];\n    }\n    const copy = [];\n    for (let i = 0; i < timeRanges.length; i++) {\n        copy.push([timeRanges.start(i), timeRanges.end(i)]);\n    }\n    return copy;\n};\n\n/**\n * Get a snapshot of current playback ranges\n * @returns {Array<Array<number>>} Array of range pairs [start, end]\n */\nconst getPlaybackRangesSnapshot = () => playbackRanges.map((range) => range.slice());\n\nconst initializeChart = () => {\n    if (!tracking) {\n        return false;\n    }\n\n    const initChart = () => {\n        if (!video) {\n            return;\n        }\n\n        let watched = [];\n        try {\n            watched = JSON.parse(video.dataset?.watchdata || '[]');\n        } catch (error) {\n            watched = [];\n        }\n        if (watched.length !== 0) {\n            existingRanges = [watched.slice()];\n            updateChart(existingRanges, []);\n        }\n    };\n\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', initChart);\n    } else {\n        initChart();\n    }\n};\n\n/**\n * Debounced chart update handler to prevent excessive updates\n */\nconst handleTimeUpdate = () => {\n    // Clear existing timeout\n    if (chartUpdateTimeout) {\n        clearTimeout(chartUpdateTimeout);\n    }\n\n    // Debounce chart updates\n    chartUpdateTimeout = setTimeout(() => {\n        let currentRanges;\n\n        // Use native video.played API if available (more accurate, handles seeks automatically)\n        if (mediaElement && mediaElement.played && mediaElement.played.length > 0) {\n            currentRanges = copyRanges(mediaElement.played);\n        } else {\n            // Fallback to manual tracking for embedded videos (YouTube/Vimeo)\n            currentRanges = getPlaybackRangesSnapshot();\n        }\n\n        updateChart([currentRanges], existingRanges);\n        chartUpdateTimeout = null;\n    }, CHART_UPDATE_DEBOUNCE);\n};\n\n/**\n * Update chart with change detection to avoid unnecessary DOM manipulation\n * @param {Array} data - New range data\n * @param {Array} existingRanges - Existing ranges for comparison\n */\nconst updateChart = (data, existingRanges) => {\n    if (!chart || !videoData) {\n        return;\n    }\n\n    // Use normalized duration for consistency\n    const vduration = getNormalizedDuration();\n\n    if (!vduration) {\n        return;\n    }\n\n    // Create hash of current data to detect changes\n    const dataHash = JSON.stringify(data) + JSON.stringify(existingRanges);\n    if (dataHash === lastChartDataHash) {\n        // Data hasn't changed, only update progress if needed\n        updateProgressOnly();\n        return;\n    }\n    lastChartDataHash = dataHash;\n\n    let opacity = 1;\n    if (data && data.length > 0) {\n        opacity = (100 / data.length) / 100;\n    } else if (existingRanges && existingRanges.length > 0) {\n        opacity = (100 / existingRanges.length) / 100;\n    }\n\n    // Use DocumentFragment for batch DOM updates\n    const fragment = document.createDocumentFragment();\n\n    if (data && data.length > 0) {\n        data.forEach((ranges) => {\n            ranges.forEach((range) => {\n                const div = document.createElement('div');\n                const left = (range[0] / vduration) * 100;\n                let width = (range[1] / vduration) * 100;\n                width -= left;\n                div.style.left = `${Math.abs(left)}%`;\n                div.style.width = `${Math.abs(width)}%`;\n                div.style.opacity = opacity;\n                fragment.appendChild(div);\n            });\n        });\n    }\n\n    // Clear and update chart in one operation\n    chart.innerHTML = '';\n    chart.appendChild(fragment);\n\n    // Calculate watchduration from current ranges\n    // Use native video.played API if available, otherwise use manual tracking\n    let currentRanges;\n    if (mediaElement && mediaElement.played && mediaElement.played.length > 0) {\n        currentRanges = copyRanges(mediaElement.played);\n    } else {\n        currentRanges = getPlaybackRangesSnapshot();\n    }\n\n    videoData.watchduration = calculateProgress(vduration, [currentRanges], false);\n    videoData.ranges = [currentRanges];\n\n    Debug.log('Watchduration calculated', {\n        ranges: currentRanges,\n        watchduration: videoData.watchduration,\n        duration: vduration,\n        usingNativeAPI: Boolean(mediaElement && mediaElement.played)\n    });\n\n    updateProgressOnly();\n};\n\n/**\n * Normalize duration value - use the most accurate source available\n * @returns {number} Normalized duration in seconds\n */\nconst getNormalizedDuration = () => {\n    // Priority: player duration > videoData duration > video element duration\n    return videoPlayer?.duration || videoData?.duration || video?.duration || 0;\n};\n\n/**\n * Check if current time is at or very close to the end (accounting for floating point precision)\n * @param {number} currentTime - Current playback time\n * @param {number} duration - Video duration\n * @returns {boolean} True if at or past the end\n */\nconst isAtEnd = (currentTime, duration) => {\n    if (!duration || duration <= 0) {\n        return false;\n    }\n    // Use epsilon (0.1 seconds) to account for floating point precision and API discrepancies\n    const EPSILON = 0.1;\n    return currentTime >= duration - EPSILON;\n};\n\n/**\n * Update progress percentage without rebuilding chart\n */\nconst updateProgressOnly = () => {\n    if (!videoData || !video) {\n        return;\n    }\n\n    const normalizedDuration = getNormalizedDuration();\n    if (!normalizedDuration) {\n        return;\n    }\n\n    // Calculate progress from furthest point reached\n    const furthestPoint = Math.max(\n        videoData.max || 0, // Server-provided max from all sessions\n        parseFloat(video?.dataset?.maxwatched || 0) // Current session's furthest point\n    );\n\n    // Use isAtEnd check for consistent end detection\n    if (isAtEnd(furthestPoint, normalizedDuration)) {\n        videoData.totalprogess = 100;\n        videoData.max = normalizedDuration;\n        if (percentageEl) {\n            percentageEl.innerText = '100%';\n        }\n        return;\n    }\n\n    const progress = calculateProgressFromFurthest(furthestPoint, normalizedDuration);\n    videoData.totalprogess = progress;\n    videoData.max = furthestPoint; // Update max with current furthest point\n\n    if (percentageEl) {\n        percentageEl.innerText = `${progress}%`;\n    }\n};\n\n/**\n * Calculate watched seconds from nested ranges using mathematical approach\n * Optimized to avoid creating large arrays for long videos\n * @param {number} end - Total duration in seconds\n * @param {Array<Array<Array<number>>>} nestedRanges - Nested array of watched ranges\n * @param {boolean} percentage - Whether to return percentage or seconds\n * @returns {string|number} Progress percentage or watched seconds\n */\nconst calculateProgress = (end, nestedRanges, percentage = true) => {\n    if (!end || end <= 0 || !nestedRanges || nestedRanges.length === 0) {\n        return percentage ? '0.00' : 0;\n    }\n\n    // Merge all ranges from all nested arrays into a single flat array\n    const allRanges = [];\n    nestedRanges.forEach(subRanges => {\n        if (Array.isArray(subRanges)) {\n            subRanges.forEach(range => {\n                if (Array.isArray(range) && range.length >= 2) {\n                    // Allow 0-based ranges (e.g., 0-5 seconds is valid)\n                    const rangeStart = Math.max(0, Math.round(range[0]));\n                    const rangeEnd = Math.min(end, Math.round(range[1]));\n                    if (rangeEnd > rangeStart) {\n                        allRanges.push([rangeStart, rangeEnd]);\n                    }\n                }\n            });\n        }\n    });\n\n    if (allRanges.length === 0) {\n        return percentage ? '0.00' : 0;\n    }\n\n    // Merge overlapping ranges\n    const mergedRanges = mergeRanges(allRanges);\n\n    // Calculate total watched seconds by summing range lengths (exclusive end)\n    let watched = 0;\n    mergedRanges.forEach(range => {\n        watched += (range[1] - range[0]);\n    });\n\n    // Ensure watched doesn't exceed total duration\n    watched = Math.min(watched, end);\n\n    if (!percentage) {\n        return watched;\n    }\n\n    const progress = (watched * 100) / end;\n    return progress.toFixed(2);\n};\n\n/**\n * Calculate progress percentage from furthest point reached\n * @param {number} furthestPoint - Furthest point reached in seconds\n * @param {number} totalDuration - Total video duration in seconds\n * @returns {number} Progress percentage (0-100)\n */\nconst calculateProgressFromFurthest = (furthestPoint, totalDuration) => {\n    if (!totalDuration || totalDuration <= 0 || furthestPoint < 0) {\n        return 0;\n    }\n\n    // Use epsilon-based comparison instead of percentage threshold\n    // This is more accurate for videos of all lengths\n    const EPSILON = 0.1; // 0.1 second tolerance for floating point precision\n    if (furthestPoint >= totalDuration - EPSILON) {\n        return 100;\n    }\n\n    const progress = Math.min(100, (furthestPoint / totalDuration) * 100);\n    return parseFloat(progress.toFixed(2));\n};\n\n/**\n * Send tracking data to server with exponential backoff on errors\n * @param {Object} data - Data to send\n * @param {boolean} retry - Whether this is a retry attempt\n */\nconst sendDataToServer = (data, retry = false) => {\n    if (!tracking) {\n        return false;\n    }\n\n    // Recalculate watchduration from current playback ranges before sending\n    if (videoData && videoData.duration) {\n        let currentRanges;\n\n        // Use native video.played API if available (more accurate, handles seeks automatically)\n        if (mediaElement && mediaElement.played && mediaElement.played.length > 0) {\n            currentRanges = copyRanges(mediaElement.played);\n        } else if (playbackRanges.length > 0) {\n            // Fallback to manual tracking for embedded videos (YouTube/Vimeo)\n            currentRanges = getPlaybackRangesSnapshot();\n        }\n\n        if (currentRanges && currentRanges.length > 0) {\n            data.watchduration = calculateProgress(videoData.duration, [currentRanges], false);\n            data.ranges = [currentRanges];\n        }\n    }\n\n    // Queue data if there's an ongoing request\n    if (sendDataQueue.length > 0 && !retry) {\n        sendDataQueue.push(data);\n        return;\n    }\n\n    Ajax.call([{\n        methodname: 'mod_videolesson_monitor',\n        args: { data: JSON.stringify(data) },\n        done: (response) => {\n            // Reset retry count on success\n            sendDataRetryCount = 0;\n\n            // Process queued data\n            if (sendDataQueue.length > 0) {\n                const nextData = sendDataQueue.shift();\n                sendDataToServer(nextData, false);\n            }\n\n            if (!videoData.notified) {\n                if (response.notify) {\n                    videoData.notified = true;\n                    Toast.add(response.notify.message, { type: response.notify.type});\n                    const badge = document.getElementById('video-progress-requirement');\n                    if (badge) {\n                        badge.classList.remove(\"d-none\");\n                    }\n                    if (response.activity_info && completiondetails) {\n                        completiondetails.innerHTML = response.activity_info;\n                    }\n                }\n            }\n        },\n        fail: (error) => {\n            sendDataRetryCount++;\n            const maxRetries = 3;\n            const baseDelay = 1000; // 1 second\n\n            if (sendDataRetryCount <= maxRetries) {\n                // Exponential backoff: 1s, 2s, 4s\n                const delay = baseDelay * Math.pow(2, sendDataRetryCount - 1);\n                Debug.warn(`Server call failed, retrying in ${delay}ms (attempt ${sendDataRetryCount}/${maxRetries})`, error);\n\n                setTimeout(() => {\n                    sendDataToServer(data, true);\n                }, delay);\n            } else {\n                Debug.error('Server call failed after max retries', error);\n                sendDataRetryCount = 0;\n                sendDataQueue = [];\n            }\n        }\n    }]);\n};\n\n/**\n * Retrieve media duration from player\n * Gets duration for external/embed sources\n */\nconst mediaData = async () => {\n    if (!videoData || !videoPlayer) {\n        return;\n    }\n    if (!videoData.duration) {\n        if (videoPlayer.duration) {\n            videoData.duration = videoPlayer.duration;\n        } else if (videoPlayer.embed && typeof videoPlayer.embed.getDuration === 'function') {\n            try {\n                const duration = videoPlayer.embed.getDuration();\n                // Handle Promise if getDuration returns one (e.g., Vimeo)\n                videoData.duration = duration instanceof Promise ? await duration : duration;\n            } catch (error) {\n                Debug.warn('Error getting embed duration', error);\n            }\n        }\n    }\n};\n\n/**\n * Show resume dialog if user has a saved position\n * @returns {Promise<Object>} Modal instance or null\n */\nconst resumeDialog = async() => {\n    if (!videoData || !videoData.leftOff) {\n        return null;\n    }\n    if (videoData.notified) {\n        return null;\n    }\n    if (videoData.leftOff === videoData.duration) {\n        return null;\n    }\n\n    try {\n        const modal = await ModalFactory.create({\n            title: getString('player:resume:modal:title', 'mod_videolesson'),\n            body: getString('player:resume:modal:body', 'mod_videolesson'),\n            type: ModalFactory.types.SAVE_CANCEL,\n            buttons: {\n                cancel: getString('player:resume:modal:no', 'mod_videolesson'),\n                save: getString('player:resume:modal:yes', 'mod_videolesson')\n            }\n        });\n\n        modal.getRoot().on(ModalEvents.save, () => {\n            handleResume();\n        });\n\n        modal.show();\n        return modal;\n    } catch (error) {\n        Debug.error('Error creating resume dialog', error);\n        return null;\n    }\n};\n\n/**\n * Handle resume action - seek to saved position and play\n */\nconst handleResume = () => {\n    if (!videoData || !videoPlayer) {\n        return;\n    }\n\n    videoData.playbackEvents.push({\n        event_type: 'resume',\n        timestamp: new Date().toISOString(),\n        position: videoData.leftOff,\n    });\n\n    try {\n        if (playerContainer) {\n            playerContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        }\n        if (videoPlayer && videoData.leftOff >= 0) {\n            // Mark as resume operation to prevent adding incorrect ranges during seek\n            fromResume = true;\n            // Update previousTime to resume position BEFORE seeking to prevent range tracking\n            previousTime = videoData.leftOff;\n            videoPlayer.currentTime = videoData.leftOff;\n            videoPlayer.play().catch(error => {\n                Debug.error('Error playing video on resume', error);\n            });\n        }\n    } catch (error) {\n        Debug.error('Error handling resume', error);\n    }\n};\n\n/**\n * Set up ready event handler\n */\nconst setupReadyHandler = () => {\n    const readyHandler = async () => {\n        Debug.log('Player ready event fired');\n        await mediaData();\n        Debug.log('Media data retrieved', {\n            duration: videoData.duration,\n            hasEmbed: Boolean(videoPlayer.embed)\n        });\n        sendDataToServer(videoData);\n    };\n    videoPlayer.on('ready', readyHandler);\n    plyrEventHandlers.push({event: 'ready', handler: readyHandler});\n};\n\n/**\n * Set up playback event handlers (play, pause, ended)\n */\nconst setupPlaybackHandlers = () => {\n    const playHandler = () => {\n        Debug.log('Play event fired', {\n            currentTime: videoPlayer.currentTime,\n            duration: videoPlayer.duration,\n            isEmbed: Boolean(videoPlayer.embed),\n            fromResume: fromResume\n        });\n        isPlaying = true;\n        videoData.playbackEvents.push({\n            event_type: 'play',\n            timestamp: new Date().toISOString(),\n            position: videoPlayer.currentTime,\n        });\n\n        // Only update previousTime if not resuming (resume already set it correctly)\n        if (!fromResume) {\n            previousTime = videoPlayer.currentTime || 0;\n        }\n\n        if (fromSeek) {\n            fromSeek = false;\n            return;\n        }\n        sendDataToServer(videoData);\n    };\n    videoPlayer.on('play', playHandler);\n    plyrEventHandlers.push({event: 'play', handler: playHandler});\n\n    const pauseHandler = () => {\n        Debug.log('Pause event fired', {\n            currentTime: videoPlayer.currentTime\n        });\n        isPlaying = false;\n        if (fromSeek) {\n            fromSeek = false;\n            return;\n        }\n        videoData.playbackEvents.push({\n            event_type: 'pause',\n            timestamp: new Date().toISOString(),\n            position: videoPlayer.currentTime,\n        });\n        sendDataToServer(videoData);\n    };\n    videoPlayer.on('pause', pauseHandler);\n    plyrEventHandlers.push({event: 'pause', handler: pauseHandler});\n\n    const endedHandler = () => {\n        Debug.log('Ended event fired', {\n            currentTime: videoPlayer.currentTime,\n            duration: videoPlayer.duration,\n            videoDataDuration: videoData.duration\n        });\n        isPlaying = false;\n        lastSendTime = 0;\n\n        // Get normalized duration - use the most accurate source available\n        const normalizedDuration = getNormalizedDuration();\n\n        // When video ends, it's definitively 100% complete\n        // This is the most reliable indicator that the video finished\n        if (normalizedDuration > 0 && video) {\n            video.dataset.maxwatched = normalizedDuration;\n            videoData.max = normalizedDuration;\n            videoData.totalprogess = 100;\n\n            // Update progress display\n            if (percentageEl) {\n                percentageEl.innerText = '100%';\n            }\n        }\n\n        videoData.playbackEvents.push({\n            event_type: 'end',\n            timestamp: new Date().toISOString(),\n            position: normalizedDuration, // Use normalized duration instead of currentTime\n        });\n        sendDataToServer(videoData);\n    };\n    videoPlayer.on('ended', endedHandler);\n    plyrEventHandlers.push({event: 'ended', handler: endedHandler});\n};\n\n/**\n * Set up seek event handlers (seeking, seeked)\n */\nconst setupSeekHandlers = () => {\n    const seekingHandler = () => {\n        Debug.log('Seeking event fired', {\n            currentTime: videoPlayer.currentTime,\n            previousTime: previousTime,\n            fromResume: fromResume\n        });\n        isPlaying = false;\n        if (seekStart === null) {\n            seekStart = previousTime;\n        }\n        fromSeek = true;\n        // If this is a resume operation, don't track the seek as a watched range\n        // The fromResume flag will be cleared in seeked handler\n    };\n    videoPlayer.on('seeking', seekingHandler);\n    plyrEventHandlers.push({event: 'seeking', handler: seekingHandler});\n\n    const seekedHandler = () => {\n        Debug.log('Seeked event fired', {\n            currentTime: videoPlayer.currentTime,\n            seekStart: seekStart,\n            fromResume: fromResume\n        });\n        const seekPosition = videoPlayer.currentTime || 0;\n        videoData.seekEvents.push({\n            timestamp: new Date().toISOString(),\n            start: seekStart,\n            position: seekPosition,\n            progress: seekPosition - seekStart,\n        });\n\n        // Update furthest point if seeked to a new maximum\n        if (video && seekPosition > parseFloat(video.dataset.maxwatched || 0)) {\n            video.dataset.maxwatched = seekPosition;\n            // Update progress only (no need to rebuild chart)\n            updateProgressOnly();\n        }\n\n        // CRITICAL: Update previousTime BEFORE clearing flags\n        // This prevents timeupdate from adding a range from seekStart to seekPosition\n        previousTime = seekPosition;\n        fromSeek = false;\n        // Clear resume flag after seek completes\n        fromResume = false;\n        seekStart = null;\n        isPlaying = !videoPlayer.paused;\n    };\n    videoPlayer.on('seeked', seekedHandler);\n    plyrEventHandlers.push({event: 'seeked', handler: seekedHandler});\n};\n\n/**\n * Set up tracking event handlers (timeupdate, volumechange, qualitychange)\n */\nconst setupTrackingHandlers = () => {\n    const timeUpdateHandler = () => {\n        const newTime = videoPlayer.currentTime || 0;\n\n        if (Math.floor(newTime) % 5 === 0 && newTime - Math.floor(newTime) < 0.1) {\n            Debug.log('Timeupdate', {\n                currentTime: newTime,\n                duration: videoPlayer.duration,\n                isPlaying: isPlaying,\n                fromSeek: fromSeek,\n                previousTime: previousTime,\n                isEmbed: Boolean(videoPlayer.embed),\n                hasMediaElement: Boolean(mediaElement)\n            });\n        }\n\n        // Only manually track ranges for embedded videos (YouTube/Vimeo)\n        // For native video elements, use video.played API instead (handles seeks automatically)\n        // Don't track ranges during seeks or resume operations\n        if (isPlaying && !fromSeek && !fromResume && !mediaElement) {\n            addPlaybackRange(previousTime, newTime);\n        }\n\n        handleTimeUpdate();\n\n        if (fromSeek) {\n            fromSeek = false;\n            previousTime = newTime; // Update previousTime immediately after seek to prevent incorrect ranges\n            return;\n        }\n\n        // Clear resume flag if it's still set (shouldn't happen, but safety check)\n        if (fromResume) {\n            fromResume = false;\n        }\n\n        if (videoPlayer.playing && video) {\n            const currentMax = parseFloat(video.dataset.maxwatched || 0);\n            const normalizedDuration = getNormalizedDuration();\n\n            // Use isAtEnd helper for consistent end detection\n            // This handles floating point precision and API discrepancies\n            if (normalizedDuration > 0 && isAtEnd(newTime, normalizedDuration)) {\n                // At or past the end - force to 100%\n                video.dataset.maxwatched = normalizedDuration;\n                videoData.max = normalizedDuration;\n                videoData.totalprogess = 100;\n                if (percentageEl) {\n                    percentageEl.innerText = '100%';\n                }\n            } else if (newTime > currentMax) {\n                video.dataset.maxwatched = newTime;\n                // Update progress only (no need to rebuild chart)\n                updateProgressOnly();\n            }\n        }\n\n        previousTime = newTime;\n        if (newTime - lastSendTime >= SEND_INTERVAL) {\n            Debug.log('Sending data to server (interval)', {\n                currentTime: newTime,\n                lastSendTime: lastSendTime,\n                progress: videoData.totalprogess\n            });\n            lastSendTime = newTime;\n            sendDataToServer(videoData);\n        }\n    };\n    videoPlayer.on('timeupdate', timeUpdateHandler);\n    plyrEventHandlers.push({event: 'timeupdate', handler: timeUpdateHandler});\n\n    const volumeChangeHandler = () => {\n        videoData.volumeChanges.push({\n            timestamp: new Date().toISOString(),\n            volume_level: Math.round(videoPlayer.volume * 100),\n            position: videoPlayer.currentTime,\n        });\n    };\n    videoPlayer.on('volumechange', volumeChangeHandler);\n    plyrEventHandlers.push({event: 'volumechange', handler: volumeChangeHandler});\n\n    const qualityChangeHandler = (event) => {\n        videoData.qualityChanges.push({\n            timestamp: new Date().toISOString(),\n            quality: event.detail.quality,\n            position: videoPlayer.currentTime,\n        });\n    };\n    videoPlayer.on('qualitychange', qualityChangeHandler);\n    plyrEventHandlers.push({event: 'qualitychange', handler: qualityChangeHandler});\n};\n\n/**\n * Set up error event handler\n */\nconst setupErrorHandler = () => {\n    const errorHandler = (event) => {\n        Debug.error('Player error event', event);\n        const error = videoPlayer.error || event?.detail || null;\n        if (error) {\n            const code = error.code ?? error.detail ?? 'unknown';\n            const message = error.message ?? error.note ?? 'Playback error';\n            videoData.errors.push({\n                timestamp: new Date().toISOString(),\n                error_type: code,\n                error_description: message,\n            });\n        }\n    };\n    videoPlayer.on('error', errorHandler);\n    plyrEventHandlers.push({event: 'error', handler: errorHandler});\n};\n\n/**\n * Initialize tracking components (chart and visibility handlers)\n * @param {Object} params - Initialization parameters\n */\nconst initializeTracking = (params) => {\n    initializeChart();\n    resumeDialog();\n\n    // Initialize furthest point from server (all sessions)\n    if (params.max && video) {\n        const serverMax = parseFloat(params.max);\n        const currentMax = parseFloat(video.dataset.maxwatched || 0);\n        // Use the maximum of server max and current max\n        video.dataset.maxwatched = Math.max(serverMax, currentMax);\n        videoData.max = Math.max(serverMax, currentMax);\n    } else if (video) {\n        videoData.max = parseFloat(video.dataset.maxwatched || 0);\n    }\n\n    // Set up visibility change handler after everything is initialized\n    visibilityChangeHandler = function() {\n        if (videoData && videoPlayer) {\n            Debug.log('Visibility change', {\n                active: !document.hidden,\n                currentTime: videoPlayer.currentTime\n            });\n            videoData.visibility.push({\n                timestamp: new Date().toISOString(),\n                active: !document.hidden,\n                position: videoPlayer.currentTime,\n            });\n        }\n    };\n    document.addEventListener('visibilitychange', visibilityChangeHandler);\n    Debug.log('Visibility change handler attached');\n};\n\n/**\n * Set up all Plyr event listeners\n */\nconst setupEventHandlers = () => {\n    Debug.log('Setting up event listeners');\n    setupReadyHandler();\n    setupPlaybackHandlers();\n    setupSeekHandlers();\n    setupTrackingHandlers();\n    setupErrorHandler();\n};\n\n/**\n * Initialize video player tracking\n * @param {Object} params - Initialization parameters\n * @param {string} params.provider - Video provider type\n * @param {string} params.externaltype - External video type (youtube/vimeo)\n * @param {boolean} params.tracking - Whether tracking is enabled\n * @param {number} params.duration - Video duration\n * @param {number} params.max - Furthest point reached from all sessions\n * @param {Array} params.subtitles - Subtitle tracks\n * @param {Object} params.video - Video element\n */\nexport const init = (params) => {\n    // Store params for potential re-initialization after bfcache restore\n    storedInitParams = params;\n\n    Debug.log('vplyr.init called', {\n        params: params\n    });\n\n    tracking = params.tracking;\n\n    // Disable tracking for unsupported embeds (no externaltype/externalvideoid)\n    if (params.externaltype === null || params.externalvideoid === null) {\n        // Check if it's an external source - if so and no type/id, disable tracking\n        if (params.source === 'external' || params.provider === 'external') {\n            tracking = false;\n        }\n    }\n\n    video = document.getElementById(\"player\");\n    mediaElement = video && video.tagName === 'VIDEO' ? video : null;\n     // eslint-disable-next-line no-undef\n    browserData = bowser.parse(window.navigator.userAgent);\n    params.video = document.getElementById(\"player\");\n\n    // Read large data from data attributes instead of params to reduce js_call_amd payload\n    const sourceurl = video?.dataset?.source || ''; // eslint-disable-line no-unused-vars\n    const sourcedata = video?.dataset?.sourcedata || '';\n    const subtitlesJson = video?.dataset?.subtitles || '[]';\n    const title = video?.dataset?.title || '';\n\n    let subtitles = [];\n    try {\n        subtitles = JSON.parse(subtitlesJson);\n    } catch (e) {\n        Debug.warn('Error parsing subtitles from data attribute', e);\n    }\n\n    // Initialize DOM element references\n    chart = document.getElementById('videolesson-chart');\n    percentageEl = document.getElementById('video-progress-total-percentage');\n    playerContainer = document.getElementById('player-container-div');\n    playerPlaceholder = document.getElementById('player-placeholder');\n    completiondetails = document.querySelector('[data-region=\"activity-information\"].activity-information');\n\n    Debug.log('Video element found', {\n        tagName: video?.tagName,\n        className: video?.className,\n        isVideo: Boolean(mediaElement),\n        isEmbed: video?.classList?.contains('plyr__video-embed')\n    });\n\n    const tracks = subtitles.map((item, index) => ({\n        kind: 'subtitles',\n        language: item.language,\n        code: item.code,\n        url: item.url,\n        ...(index === 0 && { \"default\": true }) // Set the first one as default\n    }));\n\n    if (mediaElement) {\n        addSubtitleTracks(mediaElement, tracks);\n    }\n\n    videoData = {\n        videoid: params.videoid,\n        videotitle: title, // Use from data attribute\n        source: params.provider,\n        sourcedata: sourcedata, // Use from data attribute\n        session: params.session,\n        userid: params.userid,\n        cm: params.cm,\n        timestamp: new Date().toISOString(),\n        duration: params.duration,\n        leftOff: params.leftOff,\n        max: params.max,\n        totalprogess: params.progress, // Accumulated progress,\n        watchduration: 0,\n        ranges: [],\n        playbackEvents: [],\n        volumeChanges: [],\n        qualityChanges: [],\n        seekEvents: [],\n        visibility: [],\n        errors: [],\n        city: params.city,\n        country: params.country,\n        ip: params.ip,\n        platform: browserData.platform.type,\n        browser: `${browserData.browser.name}|v${browserData.browser.version}`,\n        os: browserData.os.name,\n        notified: params.notified,\n        student: params.student,\n        externaltype: params.externaltype || null,\n        externalvideoid: params.externalvideoid || null\n    };\n\n    // initializePlayer reads sourceurl from video.dataset.source, so we don't need to pass it\n    // The data attribute is already set in the template\n    initializePlayer(params)\n        .then((videoPlyr) => {\n            videoPlayer = videoPlyr;\n            Debug.log('Player initialized', {\n                hasPlayer: Boolean(videoPlayer),\n                hasEmbed: Boolean(videoPlayer.embed),\n                embedProvider: videoPlayer.embed?.provider,\n                duration: videoPlayer.duration\n            });\n        })\n        .then(() => {\n            if (playerContainer) {\n                playerContainer.classList.remove('d-none');\n            }\n            if (playerPlaceholder) {\n                playerPlaceholder.classList.add('d-none');\n            }\n\n            setupEventHandlers();\n        })\n        .then(() => {\n            initializeTracking(params);\n\n            Debug.log('Initialization complete', {\n                hasPlayer: Boolean(videoPlayer),\n                tracking: tracking,\n                provider: videoData.source\n            });\n        })\n        .catch((error) => {\n            Debug.error('Initialization error', error);\n        });\n};\n\n/**\n * Cleanup function to remove event listeners and reset state\n * Call this when the video player is being destroyed or page is unloading\n */\nexport const cleanup = () => {\n    // Remove all Plyr event listeners\n    if (videoPlayer && plyrEventHandlers.length > 0) {\n        plyrEventHandlers.forEach(({event, handler}) => {\n            try {\n                videoPlayer.off(event, handler);\n            } catch (e) {\n                Debug.warn('Error removing Plyr event listener', {event, error: e});\n            }\n        });\n        plyrEventHandlers = [];\n    }\n\n    if (videoPlayer) {\n        try {\n            videoPlayer.destroy();\n        } catch (e) {\n            Debug.warn('Error destroying player', e);\n        }\n        videoPlayer = null;\n    }\n\n    if (visibilityChangeHandler) {\n        document.removeEventListener('visibilitychange', visibilityChangeHandler);\n        visibilityChangeHandler = null;\n    }\n\n    // Clear chart update timeout\n    if (chartUpdateTimeout) {\n        clearTimeout(chartUpdateTimeout);\n        chartUpdateTimeout = null;\n    }\n\n    // Reset all state\n    playbackRanges = [];\n    existingRanges = [];\n    fromSeek = false;\n    isPlaying = false;\n    seekStart = null;\n    previousTime = 0;\n    lastSendTime = 0;\n    lastChartDataHash = null;\n\n    // Clear DOM references\n    video = null;\n    mediaElement = null;\n    chart = null;\n    percentageEl = null;\n    playerContainer = null;\n    playerPlaceholder = null;\n    completiondetails = null;\n    videoData = null;\n\n    // Clear namespaced globals\n    if (typeof window !== 'undefined' && window.videolesson) {\n        delete window.videolesson.player;\n        delete window.videolesson.hls;\n        if (Object.keys(window.videolesson).length === 0) {\n            delete window.videolesson;\n        }\n    }\n};\n\n// Handle page lifecycle events\nif (typeof window !== 'undefined') {\n    let isNavigatingAway = false;\n\n    // Handle page restoration from bfcache (back/forward navigation)\n    window.addEventListener('pageshow', (event) => {\n        if (event.persisted) {\n            // Page was restored from bfcache - JavaScript state is reset\n            Debug.log('Page restored from bfcache, checking player state');\n\n            const playerElement = document.getElementById('player');\n            const playerContainer = document.getElementById('player-container-div');\n\n            // Check if player element exists but Plyr isn't initialized\n            // This happens when bfcache restores DOM but JS state is lost\n            if (playerElement && !videoPlayer && playerContainer && !playerContainer.classList.contains('d-none')) {\n                Debug.log('Player element exists but not initialized after bfcache restore');\n                // Moodle's AMD system should re-initialize, but if it doesn't, reload\n                // Give Moodle a moment to re-initialize modules\n                setTimeout(() => {\n                    if (!videoPlayer) {\n                        Debug.log('Player still not initialized after delay, reloading page');\n                        window.location.reload();\n                    }\n                }, 500);\n            } else if (playerElement && videoPlayer) {\n                // Player exists and is initialized - all good\n                Debug.log('Player already initialized after bfcache restore');\n            }\n        }\n        // Reset navigation flag when page becomes visible\n        isNavigatingAway = false;\n    });\n\n    // Track when user is actually navigating away (not just clicking links)\n    window.addEventListener('beforeunload', (event) => { // eslint-disable-line no-unused-vars\n        // Only mark as navigating away if we're actually leaving\n        // This prevents cleanup on same-page navigation or target=\"_blank\" links\n        isNavigatingAway = true;\n\n        // Only cleanup if page is actually being hidden\n        // Don't destroy on link clicks that might not navigate\n        if (document.visibilityState === 'hidden') {\n            cleanup();\n        }\n    });\n\n    // Cleanup on actual unload as backup (for browsers that don't fire beforeunload properly)\n    window.addEventListener('unload', () => {\n        if (isNavigatingAway) {\n            cleanup();\n        }\n    });\n}\n"],"names":["video","mediaElement","videoPlayer","browserData","videoData","chart","percentageEl","playerContainer","playerPlaceholder","completiondetails","tracking","previousTime","lastSendTime","seekStart","playbackRanges","existingRanges","fromSeek","fromResume","isPlaying","visibilityChangeHandler","plyrEventHandlers","chartUpdateTimeout","lastChartDataHash","sendDataRetryCount","sendDataQueue","storedInitParams","mergeRanges","ranges","length","sorted","slice","sort","a","b","merged","i","current","last","Math","max","push","copyRanges","timeRanges","copy","start","end","getPlaybackRangesSnapshot","map","range","updateChart","data","vduration","getNormalizedDuration","dataHash","JSON","stringify","updateProgressOnly","opacity","fragment","document","createDocumentFragment","currentRanges","forEach","div","createElement","left","width","style","abs","appendChild","innerHTML","played","watchduration","calculateProgress","Debug","log","duration","usingNativeAPI","Boolean","_videoData","_video","isAtEnd","currentTime","normalizedDuration","furthestPoint","parseFloat","dataset","maxwatched","totalprogess","innerText","progress","calculateProgressFromFurthest","nestedRanges","percentage","allRanges","subRanges","Array","isArray","rangeStart","round","rangeEnd","min","mergedRanges","watched","toFixed","totalDuration","sendDataToServer","retry","call","methodname","args","done","response","nextData","shift","notified","notify","Toast","add","message","type","badge","getElementById","classList","remove","activity_info","fail","error","delay","pow","warn","setTimeout","handleResume","playbackEvents","event_type","timestamp","Date","toISOString","position","leftOff","scrollIntoView","behavior","block","play","catch","setupReadyHandler","readyHandler","async","embed","getDuration","Promise","mediaData","hasEmbed","on","event","handler","setupTrackingHandlers","timeUpdateHandler","newTime","floor","isEmbed","hasMediaElement","Number","isNaN","_videoPlayer","MAX_RANGE_HISTORY","addPlaybackRange","clearTimeout","CHART_UPDATE_DEBOUNCE","playing","currentMax","SEND_INTERVAL","volumeChangeHandler","volumeChanges","volume_level","volume","qualityChangeHandler","qualityChanges","quality","detail","initializeTracking","params","initChart","parse","watchdata","readyState","addEventListener","initializeChart","modal","ModalFactory","create","title","body","types","SAVE_CANCEL","buttons","cancel","save","getRoot","ModalEvents","show","resumeDialog","serverMax","active","hidden","visibility","setupEventHandlers","playHandler","pauseHandler","endedHandler","videoDataDuration","setupPlaybackHandlers","seekingHandler","seekedHandler","seekPosition","seekEvents","paused","setupSeekHandlers","errorHandler","code","note","errors","error_type","error_description","setupErrorHandler","externaltype","externalvideoid","source","provider","tagName","bowser","window","navigator","userAgent","sourcedata","subtitlesJson","subtitles","e","querySelector","_video7","className","_video8","isVideo","_video9","_video9$classList","contains","tracks","item","index","kind","language","url","videoid","videotitle","session","userid","cm","city","country","ip","platform","browser","name","version","os","student","then","videoPlyr","hasPlayer","embedProvider","_videoPlayer$embed","cleanup","_ref3","off","destroy","removeEventListener","videolesson","player","hls","Object","keys","isNavigatingAway","persisted","playerElement","location","reload","visibilityState"],"mappings":"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"}